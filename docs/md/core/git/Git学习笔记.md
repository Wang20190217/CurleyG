# Git学习笔记

## 1.课程综述

### VCS出现前

开始之前。让我们先了解一下版本控制系统的演变历史，以及关于课程的主要内容，在版本控制系统出现之前。

![image-20241124211140638](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/202411242111271.png)

  我20多年前，我那个时候在研究生实验室里面跟同学们一起做项目开发。那时候还没有版本控制系统，那我们怎么开发的呢，就是在一台服务器上面把文件共享出来，然后呢，各自建个文件夹。就是以这种目录拷贝的方式。不同的人开发的东西以及各自开发自己开发的这个文件，也通过这种文件夹的形式标上一点零二点零三点表示版本号。基本就是这样的开发状态，那这种情况呢？我个人感觉啊，就是大家一起开发的公共文件是非常容易被覆盖的情况。还有开发的时候，我得不停的跟别人说，哎，我现在正在开发这个，你们先不要动啊，这样所以沟通成本是非常高的。因此，整个项目集成下来，集成效率非常低下的。而现在我到了携程工作的时候，我会去问新的同事，我说现在大学里面你们做毕业设计或者开发的时候，你们是怎么玩的？很多人告诉我，他们也没有版本控制系统。所以我个人认为，把类似于git这样的这种版本控制系统。推荐给大家是非常有必要的，那我们看到了就说右图这边这种以目录拷贝区别不同版本的这种形式。过去现在也还存在，当然时代发展了，在这几十年当中呢，已经有很多开源的，或者是商业化的版本。

### 集中式版本控制系统

![image-20241124211206626](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/202411242112456.png)

其中像cvs和SVN这种集中式的版本控制系统。也曾经被很多团队所喜欢，所接受，集中式的版本控制系统它具备的什么样？

它有一个集中的版本管理服务器，这个服务器存放了整个项目的。每个文件乃至每个文件夹一个一个的版本演变的历史，也就是说哪一天你本地。没有这套文件，从版本控制系统的服务器取也是非常容易的，它已经把历史当中的出现的这个文件呢，演变的历史一个一个的都存在了。因此呢，它具备了这种提供大家历史上的这个版本的搜索的能力，以及不同版本之间的比较的这个能力都具备了。还有它也具备这种分支管理的能力，可以让不同的分支一起做集成。那么，这样的这个特征使得集中式的版本控制系统比起之前没有版本控制系统做集成的呢？它整个的项目的效率。在集成方面是有提高的，不过啊，这个集中式的版本控制系统，大家可以看到这个computer A跟版本控制系统之间，它是不具备整像服务器一样的一个完整的版本历史。computer b也是一样的，因此这些客户端它必须时刻刻的和服务器相连来保持自己始终处于一个完整状态。那么有很多人认为，这种集中式的版本控制系统在这个速度方面是存在不足的，像林尼克斯的内核开发者林纳斯，他就有这种观点。他就是不接受cvs和svn。那么后来呢，又有一些人针对集中式的控制系统存在的不足呢，所以呢，就创造出了**分布式**的控制系统。

### 分布式版本控制系统

![image-20241124211239892](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/202411242112296.png)

分布式版本控制系统和集中式的控制系统，很大的一个差异是：

客户端使用的都有完整的一套版本库，那脱离服务端客户端是照样可以管理版本的。并且。历史以及版本比较等多数这种。版本之间的这种相关的操作都不需要去访问服务器。说分布式的控制系统比集中式的控制系统更能提高版本管理的效率。

分布式的控制系统曾经有一款商业的工具叫做bit keep，那这款也曾经提供给linux的开源的这种社区使用。但是后来是因为商业化的原因，那么像林老师，他们呢，就不能够享受bit keep的这款工具了。逼着李娜斯开发出了git，这款款本控制系统。当迪特出来的时候，很多人还对他发生质疑了，但是不久之后，因为迪特他具备的特点非常特点。导致了开源社区过了没多久就陆陆续续的都采纳git ，从SVN转移到git来进行版本控制。

![image-20241124211303314](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/202411242113544.png)

git具备什么样的特征呢？

最优的存储能力，非凡的性能 得益于尼纳斯本身的这个能，他是内核专家，也是文件系统的管理专家。所以它开发出来的git具备了最优的存储能力以及防的性能啊，

李老师他本身就是崇尚开源的，所以他开发的给他也是开源的。

git它还很容易做备份

支持离线的操作

基于git它的分支管理的成本是非常低的。而且常容易定制工作流程。



![image-20241124211320218](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/202411242113636.png)

git具有这么多的优点，git相对成熟之后，后面就开源的，或者说是商业化的，这种基于git做web服务的平台就出现了github和gitLab。

主要的重心首先是大家学会如何使用git以及了解git的工作原理。

其次，现在dev ops无处不在。开发运维这套要打破壁垒，能够提供快速，持续交付的这样一个环境的这种平台也是雨后春笋般的出现。

包括github，我们是不能不讲的，为什么呢？它是我们全球最大的开源社区，里面有非常好的开源项目值得大家借鉴，同时github除了自己开发了这个代码管理。代码评审项目管理相关这些功能以外，它还引入了跟第三方公司就它有个github的市场，这个市场里面把其他好的代码质量以及持续集成的这个工具都纳入到了当中，那么整个github提供代码。存储再加上它的商业化的合作伙伴，提供这种持续交付，持续集成的这种环境，那整个的dev ops的。全流程生命周期的这样一个平台，也就诞生了。那么github，那我们肯定要教大家学会，而且是在上面要。高的项目，这点也可以分享给大家好，

那么聊了github还得聊一聊gitLab为什么呢？

因为这个它有一个社区版本，现在很多公司呢，就是很喜欢getlab的这一块的这个，因为它又是开源的，同时，它自带了gitlab的ci，这一点是它跟github所不一样的。比如说我们的这个阿里云平台用的也是git lab，还有包括点评，去哪儿，携程一系列的公司也是在getlab的基础上做自己的代码平台的二次开发，所以呢，我们不妨也把getlab介绍给大家。那整个的话。这个课程会围绕着git以及基于git的这种dev ops，这种持续交付实践如何开展？那我们主要是围绕这个内容进行讲解的。

## 2.git安装

可以访问官方文档进行安装：

https://git-scm.com/book/zh/v2

![image-20241124214718131](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/202411242147557.png)

安装的时候一直下一步就是了。

安装是否成功

```shell
C:\Users\CurleyG>git --version //输入命令
git version 2.39.2.windows.1   //返回了git版本
```

## 3.使用git之前需要最小的配置

配置user.name和user.email

```shell
git config --global user.name "your_username"
git config --global user.email "your_email"
```

**config 的三个作用域（优先级从上到小依次递减）：**

- local 只对某个仓库有效 (存储在每个仓库的 `.git/config` 文件中) 。
- global 对当前用户所有仓库有效 (存储在用户的主目录下的 `.gitconfig` 文件中（Linux/macOS）或 `_gitconfig` 文件中（Windows）)
- system 对系统所有登录的用户有效    (存储在系统范围的配置文件中，通常位于 `/etc/gitconfig`（Linux/macOS）或 `%PROGRAMDATA%\Git\config`（Windows）)

显示config的配置，加--list

```shell
git config --list --local 
git config --list --global  
git config --list --system  
```

## 4.创建一个版本仓库，设置local信息

1.把已有的项目纳入Git管理

```shell
cd 项目代码所在的文件夹

执行 git init 
```

2.新建的项目直接使用Git管理

```shell
cd 某个文件夹
执行 git init your_project_name 命令   //name 为项目名称
cd your_project_name  //进入项目
```

3.往项目添加一个文件

```shell
cp 文件所在路径 文件目标路径
```

4.第一次添加的文件需要先执行git add(添加到暂存区)才可以commit

```shell
git add 文件名  //添加文件到暂存区 文件名可多个 也可以是文件夹
git add -u //用于将所有已经跟踪过的文件的更改标记为要提交的状态，没有跟踪的不会提交

```

5.提交文件

```shell
git commit -m'提交描述'

PS F:\wang> git commit -m'Add readme'
[master (root-commit) c9d2b49] Add readme
 1 file changed, 392 insertions(+)
 create mode 100644 "\351\241\271\347\233\256\347\273\223\346\236\204.md"
```

6.查询git目前状态

```shell
git status
```

7.查询git 日志

```shell
git log

PS F:\wang> git log
commit c9d2b490d2bc8139c0b0c96aa52bdc7dae8da53b (HEAD -> master) //提交的id 提交的分支
Author: curleyg <curleyg@163.com>  //完成提交的作者 以及 邮箱
Date:   Sun Nov 24 22:18:41 2024 +0800 //提交日期
```

## 5.认识工作区和暂存区

![image-20241124222619917](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/202411242226496.png)

git管理目录的文件会尽力三个过程：

1.第一次添加到工作目录当中首先需要执行git add 添加到暂存区

2.文件没有问题，可以执行git commit 提交到版本历史

## 6.给文件重命名的简便方法

### 方式一

```shell
mv readme readme.md //修改文件名
git add readme.md //添加修改后的文件
git rm readme //删除文件


```

`git reset --hard` 是一个非常强大的命令，它可以将您的工作目录和暂存区恢复到最近一次提交的状态。具体来说，它会执行以下几个操作：

1. **重置索引**：将索存区（即即将提交的文件列表）重置为最后一次提交的状态。
2. **重置工作目录**：将工作目录中的文件恢复到最后一次提交的状态，这会丢弃所有未提交的更改。

使用场景

- **撤销未提交的更改**：如果您对一些文件进行了修改，但还没有提交，使用 `git reset --hard` 可以撤销这些更改，将文件恢复到最后一次提交的状态。
- **清理工作目录**：如果您想快速地清除所有未提交的更改和未跟踪的文件，可以使用 `git reset --hard`。

注意事项

- **数据丢失风险**：`git reset --hard` 是一个不可逆的操作，一旦执行，所有未提交的更改将永久丢失。因此，在执行该命令前，请确保您不再需要这些更改。
- **备份工作**：如果您不确定是否要丢弃所有的更改，建议先将工作目录中的文件备份到另一个位置，然后再执行 `git reset --hard`。



### 方式二

```shell
git mv readme readme.md //一条命令抵上面三条指令
```

## 7.通过gitlog 查看版本历史

 `git log --oneline`（注意双破折号）。这个命令用于显示简洁的提交历史记录，每条提交信息只占用一行。

**显示当前分支提交：**

```shell
git log
```



**显示特定数量的提交**：

```
git log --oneline -n 5
```

这条命令会显示最近的 5 条提交记录。



**显示某个分支的提交记录：**

```
git log --oneline branch-name
```

这条命令会显示指定分支 `branch-name` 的提交记录。



**显示某个作者的提交记录：**

```
git log --oneline --author="作者名"
```

这条命令会显示指定作者的提交记录。



**显示所有分支的日志**：

```
git log --all
```

**显示分支的父子关系：**

```
git log --all --graph
```

![image-20241124230233585](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/202411242302248.png)

## 8.探究.git目录

![image-20241125085857500](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/image-20241125085857500.png)

### 1.HEAD 

```tex
ref: refs/heads/master   //指向refs文件下的heads文件下的master文件  master文件保存的是当前分支最后一次的commit id
```

- **`refs/heads/master`**：这个引用指向的是名为“master”的分支的最新一次提交。在Git中，分支实际上就是指向某个提交的指针。当你创建一个新的提交到master分支时，这个指针会向前移动，指向最新的提交。
- **`HEAD`**：这个是一个特殊的指针，它指向当前的工作分支。当你初始化一个仓库或者克隆一个仓库时，默认情况下`HEAD`会指向主分支（通常是master或main）。当你切换分支时，`HEAD`也会随之改变，指向新的分支。

当你看到`ref: refs/heads/master HEAD`这样的信息，这通常意味着你的`HEAD`是指向`refs/heads/master`的，也就是说，当前你正在工作在master分支上。这种状态也被称为`HEAD`是“附着”（attached）的，因为它明确地附着在一个具体的分支上。

当切换分支的时候，内容会发生变化

### 2.config

![image-20241125090516585](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/image-20241125090516585.png)

`.git/config` 文件是 Git 仓库的一个重要组成部分，它保存了与该仓库相关的配置信息。这些配置可以控制仓库的行为方式，包括用户信息、远程仓库地址、分支设置以及其他各种选项。以下是 `.git/config` 文件中一些常见配置项的说明：

1. **用户信息**：

   `[user]` 部分包含了用户的姓名 (`name`) 和电子邮件地址 (`email`)。这些信息会在每次提交时自动附加到提交记录中，以便标识提交者。

   ```properties
   [user]
       name = Your Name
       email = you@example.com
   ```

2. **远程仓库**：

   `[remote "origin"]` 部分定义了远程仓库的信息，包括仓库的名称和URL。通常，“origin”是默认的远程仓库名称。

   ```properties
   [remote "origin"]
   	url = https://github.com/Wang20190217/CurleyG.git
   	fetch = +refs/heads/*:refs/remotes/origin/*
   ```

3. **分支信息**：

   `[branch "master"]` 或 `[branch "main"]` 部分定义了本地分支与远程分支之间的关系，例如合并策略

   ```properties
   [branch "master"]
   	remote = origin
   	merge = refs/heads/master
   ```

4. **别名**：

   `[alias]` 部分可以用来定义命令的别名，简化常用命令的输入

   ```properties
   [alias]
       co = checkout
       br = branch
       ci = commit
       st = status
   ```

5. **核心设置**：

   [core]部分包含了一些基本的仓库设置，比如文件模式、自动换行处理等。

   ```
   [core]
       repositoryformatversion = 0
       filemode = false
       bare = false
       logallrefupdates = true
   ```

6. **差异工具和合并工具**：

   可以指定使用的差异工具和合并工具，帮助解决冲突。

   ```
   [diff]
       tool = mydifftool
   [merge]
       tool = mymergetool
   ```

7. **其他自定义设置**：

   用户可以根据需要添加更多的自定义设置，以适应特定的工作流程或个人偏好。

这个文件是纯文本格式的，可以直接用文本编辑器打开并编辑。但是，更推荐使用 Git 命令行工具来进行配置修改，

例如 `git config user.name "Your Name"` 和 `git config user.email "you@example.com"`，这样可以确保格式正确且不会破坏现有配置。

### 3.refs

![image-20241125091812378](https://curleyg-1311489005.cos.ap-shanghai.myqcloud.com/image-20241125091812378.png)

在 Git 中，`.git/refs` 目录用于存储指向仓库中特定提交（commit）的引用（references）。这些引用包括分支、标签和其他特殊指针。理解 `.git/refs` 目录的作用对于深入理解 Git 的内部工作机制非常有帮助。

.git/refs 目录结构

`.git/refs` 目录通常包含以下几个子目录：

1. **heads**：
   - 存储所有本地分支的引用。每个分支对应一个文件，文件名是分支的名称，文件内容是该分支指向的提交的哈希值。
   - 例如，`refs/heads/master` 文件的内容可能是 `abc1234567890abcdef1234567890abcdef123456`，表示 `master` 分支指向的提交的哈希值。
2. **tags**：
   - 存储所有标签的引用。每个标签对应一个文件，文件名是标签的名称，文件内容是该标签指向的提交的哈希值。
   - 例如，`refs/tags/v1.0` 文件的内容可能是 `def1234567890abcdef1234567890abcdef123456`，表示标签 `v1.0` 指向的提交的哈希值。
3. **remotes**：
   - 存储所有远程仓库的引用。每个远程仓库对应一个子目录，子目录下又包含各个远程分支的引用。
   - 例如，`refs/remotes/origin/master` 文件的内容可能是 `ghi1234567890abcdef1234567890abcdef123456`，表示远程仓库 `origin` 的 `master` 分支指向的提交的哈希值。

特殊引用

除了上述标准引用外，还有一些特殊的引用文件：

1. **HEAD**：

   存储当前工作目录所处的分支或提交的引用。通常是一个符号链接（symbolic reference），指向当前分支的引用。

   例如，`HEAD` 文件的内容可能是 `ref: refs/heads/master`，表示当前工作目录在 `master` 分支上。

   如果你在分离的 HEAD 状态下，`HEAD` 文件会直接包含一个提交的哈希值。

2. **ORIG_HEAD**：

   记录上一次 HEAD 的位置，常用于撤销操作或恢复到之前的状态。

3. **FETCH_HEAD**：

   记录最近一次 `git fetch` 操作的结果，通常用于合并或拉取操作。

4. **MERGE_HEAD**：

   在合并过程中，记录被合并分支的提交哈希值。

使用示例

你可以手动查看和修改这些引用文件，但通常建议使用 Git 命令来管理这些引用，以避免错误。

- 查看当前分支的引用：

  ```
  cat .git/refs/heads/master
  ```

- 创建一个新的分支引用：

  ```
  git update-ref refs/heads/new-branch abc1234567890abcdef1234567890abcdef123456
  ```

- 删除一个分支引用：

  ```
  git update-ref -d refs/heads/old-branch
  ```

总结

`.git/refs` 目录是 Git 仓库的核心部分之一，它存储了所有分支、标签和其他引用的信息。通过这些引用，Git 能够有效地管理和追踪仓库的历史记录。了解这些引用的工作原理有助于更好地理解和使用 Git。

### 4.object 

`.git/objects` 目录是 Git 仓库的重要组成部分，用于存储 Git 仓库中的所有对象。这些对象包括提交（commit）、树（tree）、Blob（文件内容）和标签（tag）。理解 `.git/objects` 目录的结构和作用有助于深入了解 Git 的内部工作机制。

.git/objects 目录结构

`.git/objects` 目录通常包含以下内容：

1. **对象文件**：

   每个对象文件都存储在一个以对象哈希值命名的文件中。

   对象文件的路径由其 SHA-1 哈希值的前两位和剩余部分组成。

   例如，一个对象的完整哈希值是

   ```
   abc1234567890abcdef1234567890abcdef123456
   ```

   则该对象文件的路径为：

   ```
   .git/objects/ab/c1234567890abcdef1234567890abcdef123456
   ```

2. **打包文件（pack files）**：

   - 为了提高效率和减少磁盘空间占用，Git 会将多个对象打包成一个或多个打包文件（`.pack` 和 `.idx` 文件）。
   - `.pack` 文件存储压缩后的对象数据。
   - `.idx` 文件存储索引信息，用于快速查找 `.pack` 文件中的对象。

对象类型

Git 中的对象主要有四种类型：

1. **Blob 对象**：
   - 表示文件内容。
   - 每个 Blob 对象存储一个文件的内容。
2. **Tree 对象**：
   - 表示目录结构。
   - 包含指向其他 Tree 对象和 Blob 对象的引用。
   - 类似于文件系统的目录结构。
3. **Commit 对象**：
   - 表示一次提交。
   - 包含提交信息、作者、日期、父提交等。
   - 指向一个 Tree 对象，表示该提交的目录结构。
4. **Tag 对象**：
   - 用于标记特定的提交。
   - 可以包含签名等附加信息。
   - 通常用于标记发布版本。

示例

假设你有一个提交对象，其哈希值为 `abc1234567890abcdef1234567890abcdef123456`，你可以找到该对象的文件路径：

```
.git/objects/ab/c1234567890abcdef1234567890abcdef123456
```

查看对象内容

你可以使用 `git cat-file` 命令来查看对象的内容和类型：

- **查看对象类型**：

  ```
  git cat-file -t abc1234567890abcdef1234567890abcdef123456
  ```

- **查看对象内容**：

  ```
  git cat-file -p abc1234567890abcdef1234567890abcdef123456
  ```

打包文件

Git 使用打包文件来优化存储和性能。你可以使用以下命令来查看和管理打包文件：

- **列出所有打包文件**：

  ```
  ls .git/objects/pack
  ```

- **查看打包文件的内容**：

  

  ```
  git verify-pack -v .git/objects/pack/*.pack
  ```

- **手动创建打包文件**：

  ```
  git repack
  ```

总结

`.git/objects` 目录是 Git 仓库的核心部分，用于存储所有对象。这些对象包括文件内容（Blob）、目录结构（Tree）、提交（Commit）和标签（Tag）。通过理解 `.git/objects` 目录的结构和内容，可以更好地掌握 Git 的内部工作机制，从而更高效地使用和管理 Git 仓库。



## 9.commit 、tree 和blob的关系



# 相关命令



```
git branch -v`
```

命令用于列出本地所有分支及其最新的提交信息



```
git checkout -b temp 415c5c8086e16399`
```

命令用于从指定的提交创建一个新的分支，并切换到该分支。这个命令结合了两个操作：

1. 创建一个新分支 `temp`。
2. 切换到新创建的分支 `temp`。
3. 将新分支的起点设置为指定的提交 `415c5c8086e16399`。



```shell
git checkout  temp   //temp 为分支的名称
```

切换分支



`git cat-file` 是一个 Git 命令，用于显示仓库中对象的类型或内容。`-t` 选项用于显示对象的类型。这个命令对于调试和检查 Git 仓库内部的对象非常有用。

### git cat-file 命令

```
git cat-file -t <object>
```

参数说明

- `<object>`：这是你要检查的 Git 对象的哈希值。可以是提交（commit）、树（tree）、Blob（文件内容）或标签（tag）的哈希值。

常见对象类型

- **commit**：提交对象，包含提交信息、作者、日期、父提交等。
- **tree**：树对象，表示目录结构，包含指向其他树对象和 Blob 对象的引用。
- **blob**：Blob 对象，表示文件内容。
- **tag**：标签对象，通常用于标记特定的提交，可以包含签名等附加信息。

示例

假设你有一个提交的哈希值 `abc1234567890abcdef1234567890abcdef123456`，你可以使用以下命令来检查它的类型：

```
git cat-file -t abc1234567890abcdef1234567890abcdef123456
```

如果这个哈希值对应的是一个提交对象，输出将会是：

```
commit
```

如果你有一个 Blob 对象的哈希值 `def567890abcdef1234567890abcdef123456`，你可以使用以下命令来检查它的类型：

```
git cat-file -t def567890abcdef1234567890abcdef123456
```

如果这个哈希值对应的是一个 Blob 对象，输出将会是：

```
blob
```

其他用途

- **显示对象内容**：如果你想查看对象的具体内容，可以使用 `-p` 选项：

  ```
  git cat-file -p <object>
  ```

- **检查对象大小**：如果你想查看对象的大小，可以使用 `-s` 选项：

  

  ```
  git cat-file -s <object>
  ```

总结

`git cat-file -t` 命令用于显示 Git 仓库中对象的类型。这对于理解和调试 Git 仓库的内部结构非常有用。通过结合其他选项，如 `-p` 和 `-s`，你可以获取更多关于对象的信息。